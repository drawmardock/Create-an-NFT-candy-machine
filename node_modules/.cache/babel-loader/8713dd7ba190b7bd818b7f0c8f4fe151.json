{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reducer = void 0;\n\nvar react_1 = require(\"react\");\n\nvar utils_1 = require(\"../useReducer/utils\");\n\nvar logger_1 = __importDefault(require(\"../logger\"));\n\nvar types_1 = require(\"../types\");\n\nvar tokenUtils_1 = require(\"../utils/tokenUtils\");\n\nvar reducer = function reducer(state, action) {\n  switch (action.type) {\n    case 'refresh_status_check':\n      {\n        return Object.assign(Object.assign({}, state), {\n          walletPowoInProgress: false,\n          powoFinished: false,\n          powoRequested: undefined,\n          refreshInProgress: true,\n          refreshIntervalId: action.refreshIntervalId,\n          walletToRefresh: action.walletToRefresh,\n          refreshTokenState: types_1.RefreshTokenState.CHECK_TOKEN_EXPIRATION\n        });\n      }\n\n    case 'refresh_start':\n      {\n        return Object.assign(Object.assign({}, state), {\n          gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED,\n          refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS\n        });\n      }\n\n    case 'refresh_complete':\n      {\n        return Object.assign(Object.assign({}, state), {\n          refreshTokenState: types_1.RefreshTokenState.COMPLETED,\n          gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken),\n          civicPass: Object.assign(Object.assign({}, state.civicPass), {\n            responsePayload: undefined\n          })\n        });\n      }\n\n    case 'refresh_with_powo_in_progress':\n      {\n        return Object.assign(Object.assign({}, state), {\n          renderIframe: false,\n          iframeMinimized: true,\n          gatewayStatus: types_1.GatewayStatus.CHECKING\n        });\n      }\n\n    case 'refresh_clear_interval':\n      return Object.assign(Object.assign({}, state), {\n        refreshIntervalId: undefined\n      });\n\n    case 'refresh_set_interval':\n      return Object.assign(Object.assign({}, state), {\n        refreshIntervalId: action.refreshIntervalId\n      });\n\n    case 'refresh_token_success':\n      return Object.assign(Object.assign({}, state), {\n        refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN\n      });\n\n    default:\n      return state;\n  }\n};\n\nexports.reducer = reducer;\n\nvar useRefresh = function useRefresh(_ref, state, dispatch) {\n  var stage = _ref.stage,\n      gatekeeperClient = _ref.gatekeeperClient,\n      networkConfig = _ref.networkConfig;\n  var refreshIntervalId = state.refreshIntervalId,\n      gatewayToken = state.gatewayToken,\n      gatekeeperNetworkAddress = state.gatekeeperNetworkAddress;\n\n  var logDebug = function logDebug(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.debug(\"[useRefresh] \".concat(message), obj);\n  };\n\n  var logError = function logError(message) {\n    var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return logger_1.default.error(\"[useRefresh] \".concat(message), obj);\n  };\n\n  var setTimeoutForRefresh = (0, react_1.useRef)(null);\n  /**\n   * if a refresh interval hasn't already been set, create one that will dispatch the startRefresh\n   * event, triggering the refreshFlow\n   */\n\n  var setRefreshPoll = (0, react_1.useCallback)(function (connectedWallet) {\n    var tokenExpirationMarginSeconds = networkConfig.tokenExpirationMarginSeconds;\n\n    if (!refreshIntervalId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n      var checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n      var interval = setInterval(function () {\n        dispatch({\n          type: 'refresh_status_check',\n          refreshIntervalId: interval,\n          walletToRefresh: connectedWallet\n        });\n      }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n\n      logDebug('Setting refresh token interval', {\n        expiring: gatewayToken.expiryTime,\n        checkForExpirationIntervalMilliseconds: checkForExpirationIntervalMilliseconds,\n        margin: tokenExpirationMarginSeconds\n      }); // We need to know that the interval was set even if it has not fired yet.\n      // to avoid setting duplicate intervals.\n\n      dispatch({\n        type: 'refresh_set_interval',\n        refreshIntervalId: interval\n      });\n    }\n  }, [refreshIntervalId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n  /**\n   * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n   * endpoint.\n   * On server error (5xx), retry with backoff.\n   * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n   */\n\n  var refreshTokenWithProof = (0, react_1.useCallback)(function (useWallet) {\n    return function (_ref2) {\n      var proof = _ref2.proof,\n          payload = _ref2.payload;\n      return new Promise(function (resolve, reject) {\n        logDebug('Refresh token with proof', proof);\n\n        if (gatewayToken) {\n          dispatch({\n            type: 'refresh_with_powo_in_progress'\n          });\n          gatekeeperClient().refreshToken(gatewayToken.identifier, useWallet.publicKey, payload, proof).then(function () {\n            dispatch({\n              type: 'refresh_token_success'\n            });\n            resolve();\n          }).catch(function (error) {\n            logError('Error refreshing token with proof', error);\n            reject(error);\n          });\n        }\n      });\n    };\n  }, [gatewayToken, gatekeeperClient, setRefreshPoll]);\n  /**\n   * wait until a gateway token exists in state before resolving the promise\n   */\n\n  var waitForUnexpiredGatewayToken = (0, react_1.useCallback)(function () {\n    return new Promise(function (resolve, reject) {\n      logDebug('Waiting for unexpired token');\n\n      if (setTimeoutForRefresh.current) {\n        logDebug('Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n        clearTimeout(setTimeoutForRefresh.current);\n        setTimeoutForRefresh.current = null;\n      }\n\n      var isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n\n      if (!isExpired) {\n        logDebug('Gateway token is unexpired', gatewayToken);\n        resolve();\n        return;\n      }\n\n      setTimeoutForRefresh.current = setTimeout(function () {\n        reject(new Error('Gateway token refresh has not been updated onChain'));\n      }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n      logDebug('Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n    });\n  }, [gatewayToken, setTimeoutForRefresh, gatekeeperNetworkAddress]);\n  return {\n    setRefreshPoll: setRefreshPoll,\n    refreshTokenWithProof: refreshTokenWithProof,\n    waitForUnexpiredGatewayToken: waitForUnexpiredGatewayToken\n  };\n};\n\nexports.default = useRefresh;","map":{"version":3,"sources":["/home/drawmardock/Desktop/dapp/solana-nft/metaplex/js/packages/candy-machine-ui/node_modules/@civic/solana-gateway-react/dist/esm/useHooks/useRefresh.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","reducer","react_1","require","utils_1","logger_1","types_1","tokenUtils_1","state","action","type","assign","walletPowoInProgress","powoFinished","powoRequested","undefined","refreshInProgress","refreshIntervalId","walletToRefresh","refreshTokenState","RefreshTokenState","CHECK_TOKEN_EXPIRATION","gatewayStatus","GatewayStatus","REFRESH_TOKEN_REQUIRED","IN_PROGRESS","COMPLETED","statusFromToken","gatewayToken","civicPass","responsePayload","renderIframe","iframeMinimized","CHECKING","WAIT_FOR_ON_CHAIN","useRefresh","dispatch","stage","gatekeeperClient","networkConfig","gatekeeperNetworkAddress","logDebug","message","obj","default","debug","logError","error","setTimeoutForRefresh","useRef","setRefreshPoll","useCallback","connectedWallet","tokenExpirationMarginSeconds","expiryTime","checkForExpirationIntervalMilliseconds","getTokenRefreshIntervalMilliseconds","interval","setInterval","expiring","margin","refreshTokenWithProof","useWallet","proof","payload","Promise","resolve","reject","refreshToken","identifier","publicKey","then","catch","waitForUnexpiredGatewayToken","current","clearTimeout","isExpired","hasExpired","setTimeout","Error","waitForTokenRefreshTimoutMilliseconds"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.reducer = void 0;\nconst react_1 = require(\"react\");\nconst utils_1 = require(\"../useReducer/utils\");\nconst logger_1 = __importDefault(require(\"../logger\"));\nconst types_1 = require(\"../types\");\nconst tokenUtils_1 = require(\"../utils/tokenUtils\");\nconst reducer = (state, action) => {\n    switch (action.type) {\n        case 'refresh_status_check': {\n            return Object.assign(Object.assign({}, state), { walletPowoInProgress: false, powoFinished: false, powoRequested: undefined, refreshInProgress: true, refreshIntervalId: action.refreshIntervalId, walletToRefresh: action.walletToRefresh, refreshTokenState: types_1.RefreshTokenState.CHECK_TOKEN_EXPIRATION });\n        }\n        case 'refresh_start': {\n            return Object.assign(Object.assign({}, state), { gatewayStatus: types_1.GatewayStatus.REFRESH_TOKEN_REQUIRED, refreshTokenState: types_1.RefreshTokenState.IN_PROGRESS });\n        }\n        case 'refresh_complete': {\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.COMPLETED, gatewayStatus: (0, utils_1.statusFromToken)(state, state.gatewayToken), civicPass: Object.assign(Object.assign({}, state.civicPass), { responsePayload: undefined }) });\n        }\n        case 'refresh_with_powo_in_progress': {\n            return Object.assign(Object.assign({}, state), { renderIframe: false, iframeMinimized: true, gatewayStatus: types_1.GatewayStatus.CHECKING });\n        }\n        case 'refresh_clear_interval':\n            return Object.assign(Object.assign({}, state), { refreshIntervalId: undefined });\n        case 'refresh_set_interval':\n            return Object.assign(Object.assign({}, state), { refreshIntervalId: action.refreshIntervalId });\n        case 'refresh_token_success':\n            return Object.assign(Object.assign({}, state), { refreshTokenState: types_1.RefreshTokenState.WAIT_FOR_ON_CHAIN });\n        default:\n            return state;\n    }\n};\nexports.reducer = reducer;\nconst useRefresh = ({ stage, gatekeeperClient, networkConfig, }, state, dispatch) => {\n    const { refreshIntervalId, gatewayToken, gatekeeperNetworkAddress } = state;\n    const logDebug = (message, obj = null) => logger_1.default.debug(`[useRefresh] ${message}`, obj);\n    const logError = (message, obj = null) => logger_1.default.error(`[useRefresh] ${message}`, obj);\n    const setTimeoutForRefresh = (0, react_1.useRef)(null);\n    /**\n     * if a refresh interval hasn't already been set, create one that will dispatch the startRefresh\n     * event, triggering the refreshFlow\n     */\n    const setRefreshPoll = (0, react_1.useCallback)((connectedWallet) => {\n        const { tokenExpirationMarginSeconds } = networkConfig;\n        if (!refreshIntervalId && (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime)) {\n            const checkForExpirationIntervalMilliseconds = (0, tokenUtils_1.getTokenRefreshIntervalMilliseconds)(gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime, tokenExpirationMarginSeconds);\n            const interval = setInterval(() => {\n                dispatch({\n                    type: 'refresh_status_check',\n                    refreshIntervalId: interval,\n                    walletToRefresh: connectedWallet,\n                });\n            }, checkForExpirationIntervalMilliseconds); // this will be cleared on completion\n            logDebug('Setting refresh token interval', {\n                expiring: gatewayToken.expiryTime,\n                checkForExpirationIntervalMilliseconds,\n                margin: tokenExpirationMarginSeconds,\n            });\n            // We need to know that the interval was set even if it has not fired yet.\n            // to avoid setting duplicate intervals.\n            dispatch({\n                type: 'refresh_set_interval',\n                refreshIntervalId: interval,\n            });\n        }\n    }, [refreshIntervalId, stage, gatewayToken, networkConfig.tokenExpirationMarginSeconds]);\n    /**\n     * use the passed proof of wallet ownership string to call the gatekeeper refresh token\n     * endpoint.\n     * On server error (5xx), retry with backoff.\n     * On all other errors, e.g. 400, move to a REFRESH_FAILED state.\n     */\n    const refreshTokenWithProof = (0, react_1.useCallback)((useWallet) => ({ proof, payload }) => {\n        return new Promise((resolve, reject) => {\n            logDebug('Refresh token with proof', proof);\n            if (gatewayToken) {\n                dispatch({ type: 'refresh_with_powo_in_progress' });\n                gatekeeperClient()\n                    .refreshToken(gatewayToken.identifier, useWallet.publicKey, payload, proof)\n                    .then(() => {\n                    dispatch({ type: 'refresh_token_success' });\n                    resolve();\n                })\n                    .catch((error) => {\n                    logError('Error refreshing token with proof', error);\n                    reject(error);\n                });\n            }\n        });\n    }, [gatewayToken, gatekeeperClient, setRefreshPoll]);\n    /**\n     * wait until a gateway token exists in state before resolving the promise\n     */\n    const waitForUnexpiredGatewayToken = (0, react_1.useCallback)(() => {\n        return new Promise((resolve, reject) => {\n            logDebug('Waiting for unexpired token');\n            if (setTimeoutForRefresh.current) {\n                logDebug('Clearing interval for gatewayToken', setTimeoutForRefresh.current);\n                clearTimeout(setTimeoutForRefresh.current);\n                setTimeoutForRefresh.current = null;\n            }\n            const isExpired = (gatewayToken === null || gatewayToken === void 0 ? void 0 : gatewayToken.expiryTime) && (0, tokenUtils_1.hasExpired)(gatewayToken.expiryTime);\n            if (!isExpired) {\n                logDebug('Gateway token is unexpired', gatewayToken);\n                resolve();\n                return;\n            }\n            setTimeoutForRefresh.current = setTimeout(() => {\n                reject(new Error('Gateway token refresh has not been updated onChain'));\n            }, networkConfig.waitForTokenRefreshTimoutMilliseconds);\n            logDebug('Starting check for Gateway token expiration timeout with identifier', setTimeoutForRefresh.current);\n        });\n    }, [gatewayToken, setTimeoutForRefresh, gatekeeperNetworkAddress]);\n    return {\n        setRefreshPoll,\n        refreshTokenWithProof,\n        waitForUnexpiredGatewayToken,\n    };\n};\nexports.default = useRefresh;\n"]},"metadata":{},"sourceType":"script"}